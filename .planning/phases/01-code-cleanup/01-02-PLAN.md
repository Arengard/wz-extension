---
phase: 01-code-cleanup
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/into_wz_function.cpp
autonomous: true

must_haves:
  truths:
    - "into_wz_function.cpp contains zero goto statements"
    - "Error flow uses early returns with OutputResults calls"
    - "IntoWzExecute is decomposed into sub-functions by concern"
    - "Each extracted function has a brief doc comment"
    - "Error messages include table name and row number for insert failures"
    - "The re-entry path (already-executed check) uses OutputResults"
    - "Transaction ROLLBACK is issued on every error path after BEGIN TRANSACTION"
    - "When source data contains a guiVorlaufID column, its value is used instead of generating a new UUID"
  artifacts:
    - path: "src/into_wz_function.cpp"
      provides: "Restructured main execution with extracted sub-functions and early returns"
      contains: "OutputResults"
    - path: "src/into_wz_function.cpp"
      provides: "Sub-function for Vorlauf insertion"
      contains: "InsertVorlauf"
    - path: "src/into_wz_function.cpp"
      provides: "Sub-function for Primanota insertion"
      contains: "InsertPrimanota"
  key_links:
    - from: "IntoWzExecute"
      to: "OutputResults"
      via: "function call before every return"
      pattern: "OutputResults.*output"
    - from: "IntoWzExecute"
      to: "InsertVorlauf"
      via: "function call in transaction block"
      pattern: "InsertVorlauf"
    - from: "IntoWzExecute"
      to: "InsertPrimanota"
      via: "function call in transaction block"
      pattern: "InsertPrimanota"
    - from: "IntoWzExecute"
      to: "guiVorlaufID column check"
      via: "FindColumnIndex before GenerateUUID"
      pattern: "FindColumnIndex.*guiVorlaufID"
---

<objective>
Replace all goto-based error flow in IntoWzExecute with early returns and extracted sub-functions. Extract OutputResults, LoadSourceData, ValidateDuplicates, InsertVorlauf, and InsertPrimanota as static functions. Fix the guiVorlaufID bug (user-provided values ignored). Improve error messages to include table name and row context.

Purpose: Eliminate goto spaghetti so the error flow is readable, testable, and maintainable. Fix the guiVorlaufID override bug reported by the user. This completes the Phase 1 code cleanup goal.
Output: A restructured into_wz_function.cpp with zero gotos, extracted sub-functions, better error messages, and the guiVorlaufID fix.
</objective>

<execution_context>
@C:\Users\Ramon.Ljevo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Ramon.Ljevo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\wz-extension\.planning\PROJECT.md
@C:\wz-extension\.planning\ROADMAP.md
@C:\wz-extension\.planning\STATE.md
@C:\wz-extension\.planning\phases\01-code-cleanup\01-CONTEXT.md
@C:\wz-extension\.planning\phases\01-code-cleanup\01-RESEARCH.md
@C:\wz-extension\.planning\codebase\CONVENTIONS.md

Prior plan summary (needed -- modifies same file):
@C:\wz-extension\.planning\phases\01-code-cleanup\01-01-SUMMARY.md

Source file to restructure:
@C:\wz-extension\src\into_wz_function.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract sub-functions from IntoWzExecute</name>
  <files>src/into_wz_function.cpp</files>
  <action>
Extract the following static functions from IntoWzExecute, placing them ABOVE IntoWzExecute in the file (below existing helpers like AddErrorResult/AddSuccessResult). Each function gets a brief doc comment (purpose, params). All functions use PascalCase. All are `static` (file-scoped).

**1. OutputResults** -- Output accumulated results to DataChunk.
```cpp
// Output accumulated results from bind_data to the DataChunk.
// Handles pagination: picks up from global_state.current_idx.
static void OutputResults(IntoWzBindData &bind_data,
                          IntoWzGlobalState &global_state,
                          DataChunk &output)
```
Extract from the `output_results:` label block (lines 904-918) AND the re-entry block (lines 666-684). Both blocks do the same thing. The new function replaces both. Must handle the empty case (set cardinality 0 and return when current_idx >= results.size()).

**2. LoadSourceData** -- Load all rows from the DuckDB source table into bind_data.
```cpp
// Read source table into bind_data.source_columns, source_types, and source_rows.
// Returns true on success, sets error_message on failure.
static bool LoadSourceData(ClientContext &context,
                           IntoWzBindData &bind_data,
                           string &error_message)
```
Extract Step 2 logic (lines 710-740). Creates a new Connection, queries the source table, populates bind_data.source_columns, source_types, and source_rows. On query error: set error_message = "Failed to read source table: " + error. On empty result: set error_message = "Source table is empty". Return false on either failure.

**3. ValidateDuplicates** -- Check for duplicate Primanota IDs in MSSQL.
```cpp
// Check if any guiPrimanotaID values already exist in tblPrimanota.
// Returns true if no duplicates (safe to proceed), false if duplicates found.
// Sets error_message with duplicate details on failure.
static bool ValidateDuplicates(ClientContext &context,
                               IntoWzBindData &bind_data,
                               string &error_message)
```
Extract Step 3 logic (lines 751-776). Finds guiPrimanotaID column, extracts IDs, calls CheckDuplicates. If column not found, return true (no IDs to check). If duplicates found, format the error message with the duplicate list (first 5 + "and N more"). Return false.

**4. InsertVorlauf** -- Insert the Vorlauf header record.
```cpp
// Insert a single tblVorlauf record via the transaction connection.
// Returns true on success, sets error_message on failure.
static bool InsertVorlauf(Connection &txn_conn,
                          IntoWzBindData &bind_data,
                          const string &vorlauf_id,
                          const string &date_from,
                          const string &date_to,
                          const string &bezeichnung,
                          string &error_message)
```
Extract the Vorlauf INSERT logic from Step 5 (lines 825-843). Calls BuildVorlaufInsertSQL and ExecuteMssqlStatementWithConn. On failure: set error_message = "Failed to insert Vorlauf: " + sql_error. Does NOT rollback (caller handles rollback). Return bool.

**5. InsertPrimanota** -- Insert Primanota rows in batches.
```cpp
// Insert all source rows into tblPrimanota in batches of 100.
// Returns true on success, sets total_rows and error_message on failure.
static bool InsertPrimanota(Connection &txn_conn,
                            IntoWzBindData &bind_data,
                            const string &vorlauf_id,
                            const string &date_to,
                            int64_t &total_rows,
                            string &error_message)
```
Extract Step 6 logic (lines 854-887). Iterates source_rows in batches of 100, calls BuildPrimanotaInsertSQL and ExecuteMssqlStatementWithConn for each batch. On failure: set error_message = "Failed to insert tblPrimanota rows {batch_start}-{batch_end-1}: " + sql_error (improved from current "Insert failed at row N"). Does NOT rollback (caller handles). Accumulates total_rows. Return bool.

IMPORTANT: Keep all other existing functions exactly where they are (ParseSollHaben, ColumnMapping, GenerateUUID, EscapeSqlString, FormatSqlValue, FindDateRange, CheckDuplicates, BuildVorlaufInsertSQL, BuildPrimanotaInsertSQL, ExecuteMssqlQuery, ExecuteMssqlStatementWithConn, ExecuteMssqlStatement, IntoWzBind, IntoWzInitGlobal, AddErrorResult, AddSuccessResult, RegisterIntoWzFunction). Do not change their signatures or move them.
  </action>
  <verify>
- Grep for "static void OutputResults" -- exactly 1 match in into_wz_function.cpp
- Grep for "static bool LoadSourceData" -- exactly 1 match
- Grep for "static bool ValidateDuplicates" -- exactly 1 match
- Grep for "static bool InsertVorlauf" -- exactly 1 match
- Grep for "static bool InsertPrimanota" -- exactly 1 match
- Each function has a comment line above it explaining purpose
  </verify>
  <done>
Five sub-functions extracted as static functions in into_wz_function.cpp, each with a doc comment, placed above IntoWzExecute.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite IntoWzExecute with early returns and fix guiVorlaufID bug</name>
  <files>src/into_wz_function.cpp</files>
  <action>
Rewrite IntoWzExecute to use the extracted sub-functions and early returns. Remove all 9 goto statements and the `output_results:` label. The function structure should be:

```cpp
static void IntoWzExecute(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {
    auto &bind_data = data_p.bind_data->CastNoConst<IntoWzBindData>();
    auto &global_state = data_p.global_state->Cast<IntoWzGlobalState>();

    // Re-entry: return remaining results (DuckDB calls this multiple times for pagination)
    if (bind_data.executed) {
        OutputResults(bind_data, global_state, output);
        return;
    }
    bind_data.executed = true;
    auto start_time = std::chrono::high_resolution_clock::now();

    // Step 1: Validate required parameters
    if (bind_data.gui_verfahren_id.empty()) {
        AddErrorResult(bind_data, "ERROR", "gui_verfahren_id is required");
        OutputResults(bind_data, global_state, output);
        return;
    }
    if (bind_data.source_table.empty()) {
        AddErrorResult(bind_data, "ERROR", "source_table is required");
        OutputResults(bind_data, global_state, output);
        return;
    }

    // Step 2: Load source data
    string error_msg;
    if (!LoadSourceData(context, bind_data, error_msg)) {
        AddErrorResult(bind_data, "ERROR", error_msg);
        OutputResults(bind_data, global_state, output);
        return;
    }

    // Step 3: Check for duplicate Primanota IDs
    if (!ValidateDuplicates(context, bind_data, error_msg)) {
        AddErrorResult(bind_data, "ERROR", error_msg);
        OutputResults(bind_data, global_state, output);
        return;
    }

    // Step 4: Prepare Vorlauf data
    // BUG FIX: Check if source data provides guiVorlaufID column.
    // If present, use that value. Only generate UUID if not provided.
    string vorlauf_id;
    idx_t vorlauf_id_col = FindColumnIndex(bind_data.source_columns, "guiVorlaufID");
    if (vorlauf_id_col != DConstants::INVALID_INDEX
        && !bind_data.source_rows.empty()
        && vorlauf_id_col < bind_data.source_rows[0].size()
        && !bind_data.source_rows[0][vorlauf_id_col].IsNull()) {
        vorlauf_id = bind_data.source_rows[0][vorlauf_id_col].ToString();
    } else {
        vorlauf_id = GenerateUUID();
    }

    auto date_range = FindDateRange(bind_data.source_rows, bind_data.source_columns);
    string date_from = date_range.first;
    string date_to = date_range.second;

    if (date_from.empty()) {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        char buffer[32];
        std::strftime(buffer, sizeof(buffer), "%Y-%m-01", std::localtime(&time));
        date_from = string(buffer);
    }
    if (date_to.empty()) {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        char buffer[32];
        std::strftime(buffer, sizeof(buffer), "%Y-%m-%d", std::localtime(&time));
        date_to = string(buffer);
    }

    string bezeichnung = DeriveVorlaufBezeichnung(date_from, date_to);

    // Step 5: Begin transaction and insert Vorlauf
    auto &txn_db = DatabaseInstance::GetDatabase(context);
    Connection txn_conn(txn_db);

    if (!ExecuteMssqlStatementWithConn(txn_conn, "BEGIN TRANSACTION", error_msg)) {
        AddErrorResult(bind_data, "ERROR", "Failed to begin transaction: " + error_msg);
        OutputResults(bind_data, global_state, output);
        return;
    }

    auto vorlauf_start = std::chrono::high_resolution_clock::now();
    if (!InsertVorlauf(txn_conn, bind_data, vorlauf_id, date_from, date_to, bezeichnung, error_msg)) {
        string rollback_err;
        ExecuteMssqlStatementWithConn(txn_conn, "ROLLBACK", rollback_err);
        AddErrorResult(bind_data, "tblVorlauf", error_msg, vorlauf_id);
        OutputResults(bind_data, global_state, output);
        return;
    }

    auto vorlauf_end = std::chrono::high_resolution_clock::now();
    double vorlauf_duration = std::chrono::duration<double>(vorlauf_end - vorlauf_start).count();
    AddSuccessResult(bind_data, "tblVorlauf", 1, vorlauf_id, vorlauf_duration);

    // Step 6: Insert Primanota rows
    auto primanota_start = std::chrono::high_resolution_clock::now();
    int64_t total_rows = 0;
    if (!InsertPrimanota(txn_conn, bind_data, vorlauf_id, date_to, total_rows, error_msg)) {
        string rollback_err;
        ExecuteMssqlStatementWithConn(txn_conn, "ROLLBACK", rollback_err);
        AddErrorResult(bind_data, "tblPrimanota", error_msg, vorlauf_id);
        OutputResults(bind_data, global_state, output);
        return;
    }

    // Step 7: Commit transaction
    if (!ExecuteMssqlStatementWithConn(txn_conn, "COMMIT", error_msg)) {
        AddErrorResult(bind_data, "ERROR", "Failed to commit transaction: " + error_msg, vorlauf_id);
        OutputResults(bind_data, global_state, output);
        return;
    }

    auto primanota_end = std::chrono::high_resolution_clock::now();
    double primanota_duration = std::chrono::duration<double>(primanota_end - primanota_start).count();
    AddSuccessResult(bind_data, "tblPrimanota", total_rows, vorlauf_id, primanota_duration);

    // Output results
    OutputResults(bind_data, global_state, output);
}
```

Key changes from current code:
1. **Zero gotos** -- every error path calls `OutputResults` then `return`
2. **Re-entry path simplified** -- uses `OutputResults` function instead of duplicated code
3. **No `output_results:` label** -- label and its code block are gone
4. **No extra braces** -- the current code has a `{...}` block wrapping steps 2-7 (lines 705-902) to manage scope. With early returns, this wrapping block is unnecessary. Remove it.
5. **guiVorlaufID bug fix** -- Step 4 now checks source data for a `guiVorlaufID` column before generating a UUID. Takes the value from the first source row if present.
6. **Improved error messages** -- InsertVorlauf uses "Failed to insert Vorlauf: ..." and InsertPrimanota uses "Failed to insert tblPrimanota rows N-M: ..." (done in Task 1's extracted functions)

CRITICAL: Do not change any code outside IntoWzExecute. The extracted sub-functions from Task 1 handle the internal logic. This task ONLY rewrites the IntoWzExecute function body.
  </action>
  <verify>
- Grep for "goto" in into_wz_function.cpp -- zero matches
- Grep for "output_results:" in into_wz_function.cpp -- zero matches
- Grep for "OutputResults" in into_wz_function.cpp -- multiple matches (in extracted function + all call sites)
- Grep for "FindColumnIndex.*guiVorlaufID" in into_wz_function.cpp -- at least 1 match (the bug fix)
- Verify every error path after "BEGIN TRANSACTION" includes a ROLLBACK before OutputResults+return
- Verify the function has no orphan braces from the old scope block
  </verify>
  <done>
IntoWzExecute contains zero goto statements. All error flow uses early returns with OutputResults. The re-entry path uses OutputResults. Every post-BEGIN-TRANSACTION error path issues ROLLBACK. guiVorlaufID from source data is respected when present. Error messages include table names and row context.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `grep -c "goto" src/into_wz_function.cpp` returns 0
2. `grep -c "output_results:" src/into_wz_function.cpp` returns 0
3. `grep -c "OutputResults" src/into_wz_function.cpp` returns 7+ (1 definition + 6+ call sites)
4. Five extracted sub-functions exist: OutputResults, LoadSourceData, ValidateDuplicates, InsertVorlauf, InsertPrimanota
5. Each extracted function has a doc comment
6. The guiVorlaufID column is checked before UUID generation
7. Error messages for insert failures include table name and row context
8. All transaction error paths include ROLLBACK
</verification>

<success_criteria>
- into_wz_function.cpp contains zero goto statements and zero goto labels
- IntoWzExecute is decomposed into 5 extracted sub-functions + a clean orchestration body
- Each extracted function has a brief doc comment
- Error messages are specific: include table name, row range, and MSSQL error text
- Re-entry path uses OutputResults (no duplicated result-output code)
- Every error path after BEGIN TRANSACTION issues ROLLBACK before returning
- guiVorlaufID from source data is used when present; UUID generated only as fallback
- The function is readable: clear step-by-step flow, no nested scope blocks
</success_criteria>

<output>
After completion, create `.planning/phases/01-code-cleanup/01-02-SUMMARY.md`
</output>
