---
phase: 02-transaction-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/into_wz_function.cpp]
autonomous: true

must_haves:
  truths:
    - "A failing tblPrimanota insert leaves zero new rows in both tblVorlauf and tblPrimanota"
    - "A failing tblVorlauf insert leaves zero new rows in tblVorlauf"
    - "The 'cannot rollback - no transaction is active' error never appears regardless of which insert fails"
    - "Error messages include the target table name (tblVorlauf or tblPrimanota) and the underlying MSSQL error text"
  artifacts:
    - path: "src/into_wz_function.cpp"
      provides: "Transaction handling with C++ API and try/catch error flow"
      contains: "txn_conn.BeginTransaction"
  key_links:
    - from: "IntoWzExecute transaction block"
      to: "DuckDB Connection::BeginTransaction/Commit/Rollback"
      via: "C++ API calls replacing raw SQL strings"
      pattern: "txn_conn\\.(BeginTransaction|Commit|Rollback)\\(\\)"
    - from: "catch block"
      to: "HasActiveTransaction guard"
      via: "conditional rollback prevents 'no transaction active' error"
      pattern: "HasActiveTransaction.*Rollback"
---

<objective>
Replace the raw SQL transaction strings (`"BEGIN TRANSACTION"`, `"COMMIT"`, `"ROLLBACK"`) with DuckDB's C++ transaction API (`BeginTransaction()`, `Commit()`, `Rollback()`) and restructure the insert error flow from if/else chains to a single try/catch block with `HasActiveTransaction()` guard.

Purpose: Eliminates the "cannot rollback - no transaction is active" error that occurs when DuckDB auto-invalidates a failed transaction before our explicit ROLLBACK runs. Delivers the all-or-nothing guarantee that is this project's core value.

Output: Modified `src/into_wz_function.cpp` with working transaction lifecycle.
</objective>

<execution_context>
@C:\Users\Ramon.Ljevo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Ramon.Ljevo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-transaction-fix/02-RESEARCH.md
@.planning/phases/01-code-cleanup/01-02-SUMMARY.md
@src/into_wz_function.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace raw SQL transaction control with C++ API and try/catch</name>
  <files>src/into_wz_function.cpp</files>
  <action>
Rewrite Steps 5-7 of IntoWzExecute (lines 903-958) to use DuckDB's C++ transaction API with a try/catch block. The current code at lines 907-958 uses `ExecuteMssqlStatementWithConn(txn_conn, "BEGIN TRANSACTION", ...)` and similar raw SQL strings.

Replace with:

1. Keep the Connection creation: `auto &txn_db = DatabaseInstance::GetDatabase(context); Connection txn_conn(txn_db);`

2. Wrap Steps 5-7 in a try/catch block:

```cpp
try {
    txn_conn.BeginTransaction();

    // Step 5: Insert Vorlauf
    auto vorlauf_start = std::chrono::high_resolution_clock::now();
    if (!InsertVorlauf(txn_conn, bind_data, vorlauf_id, date_from, date_to, bezeichnung, error_msg)) {
        throw std::runtime_error(error_msg);
    }
    auto vorlauf_end = std::chrono::high_resolution_clock::now();
    double vorlauf_duration = std::chrono::duration<double>(vorlauf_end - vorlauf_start).count();
    AddSuccessResult(bind_data, "tblVorlauf", 1, vorlauf_id, vorlauf_duration);

    // Step 6: Insert Primanota rows
    auto primanota_start = std::chrono::high_resolution_clock::now();
    int64_t total_rows = 0;
    if (!InsertPrimanota(txn_conn, bind_data, vorlauf_id, date_to, total_rows, error_msg)) {
        throw std::runtime_error(error_msg);
    }

    // Step 7: Commit transaction
    txn_conn.Commit();

    auto primanota_end = std::chrono::high_resolution_clock::now();
    double primanota_duration = std::chrono::duration<double>(primanota_end - primanota_start).count();
    AddSuccessResult(bind_data, "tblPrimanota", total_rows, vorlauf_id, primanota_duration);

} catch (const std::exception &e) {
    if (txn_conn.HasActiveTransaction()) {
        try {
            txn_conn.Rollback();
        } catch (...) {
            // Transaction already cleaned up by DuckDB
        }
    }
    AddErrorResult(bind_data, "ERROR", e.what(), vorlauf_id);
}
```

3. After the try/catch block, call `OutputResults(bind_data, global_state, output);` unconditionally (both success and error paths accumulate results, then output once).

Key points:
- `BeginTransaction()` replaces `ExecuteMssqlStatementWithConn(txn_conn, "BEGIN TRANSACTION", ...)`. It internally does the same `Query("BEGIN TRANSACTION")` but throws on failure instead of returning bool.
- `Commit()` replaces `ExecuteMssqlStatementWithConn(txn_conn, "COMMIT", ...)`. It propagates commit to the MSSQL attached database via MetaTransaction.
- `Rollback()` is guarded by `HasActiveTransaction()` to prevent the "cannot rollback - no transaction is active" error. The inner try/catch around Rollback() is a belt-and-suspenders safeguard.
- The tblVorlauf success result is added BEFORE tblPrimanota insert starts. If Primanota fails, the catch block clears all results by adding an ERROR result. This matches the current behavior where success results accumulate during the transaction.
- NOTE: On error, the catch block should add an error result that identifies which table failed. The error message from InsertVorlauf already contains "Failed to insert Vorlauf:" prefix, and InsertPrimanota already contains "Failed to insert tblPrimanota rows X-Y:" prefix. These propagate through `throw std::runtime_error(error_msg)` into `e.what()`.

IMPORTANT: The existing `InsertVorlauf` and `InsertPrimanota` functions keep their bool-return pattern. We do NOT refactor them to throw exceptions. The try/catch at the call site converts their `false` returns into throws.

IMPORTANT: When the catch block fires, it means the transaction failed. The previously-added tblVorlauf success result (if any) is now misleading since we rolled back. To handle this correctly: clear `bind_data.results` in the catch block before adding the error result. This ensures the output shows only the error, not a phantom "success" for tblVorlauf that was rolled back.

Specifically in the catch block:
```cpp
} catch (const std::exception &e) {
    if (txn_conn.HasActiveTransaction()) {
        try {
            txn_conn.Rollback();
        } catch (...) {
            // Transaction already cleaned up by DuckDB
        }
    }
    bind_data.results.clear();
    AddErrorResult(bind_data, "ERROR", e.what(), vorlauf_id);
}
```
  </action>
  <verify>
Search the file for these patterns:
1. `txn_conn.BeginTransaction()` appears exactly once
2. `txn_conn.Commit()` appears exactly once (in IntoWzExecute; the one in RegisterIntoWzFunction is separate)
3. `txn_conn.Rollback()` appears exactly once, inside a `HasActiveTransaction()` guard
4. Zero occurrences of `"BEGIN TRANSACTION"`, `"COMMIT"`, or `"ROLLBACK"` as raw SQL strings in IntoWzExecute (the strings may still exist in RegisterIntoWzFunction or elsewhere -- that's fine)
5. Zero occurrences of `ExecuteMssqlStatementWithConn` called with transaction control SQL in IntoWzExecute
6. The file compiles: no syntax errors visible in the code structure
  </verify>
  <done>
Steps 5-7 of IntoWzExecute use `BeginTransaction()`, `Commit()`, and `HasActiveTransaction()`-guarded `Rollback()` instead of raw SQL strings. Error flow uses try/catch instead of per-statement if/else with manual ROLLBACK.
  </done>
</task>

<task type="auto">
  <name>Task 2: Standardize error message table names</name>
  <files>src/into_wz_function.cpp</files>
  <action>
In the `InsertVorlauf` function (around line 759), the error message says `"Failed to insert Vorlauf: "`. Change it to `"Failed to insert into tblVorlauf: "` to match the table name format used in TXN-02 requirements and to be consistent with `InsertPrimanota` which already uses `"Failed to insert tblPrimanota rows"`.

Change line 759 from:
```cpp
error_message = "Failed to insert Vorlauf: " + error_message;
```
to:
```cpp
error_message = "Failed to insert into tblVorlauf: " + error_message;
```

This is a single-line change. Do NOT change anything else in InsertVorlauf or InsertPrimanota.

Also verify that InsertPrimanota's error message (around line 799) already says `"Failed to insert tblPrimanota rows"` -- if so, update it to `"Failed to insert into tblPrimanota (rows "` for consistency with the format `"Failed to insert into {table}: {mssql_error}"`.

Change line 799-801 from:
```cpp
error_message = "Failed to insert tblPrimanota rows " +
    std::to_string(batch_start) + "-" + std::to_string(batch_end - 1) +
    ": " + error_message;
```
to:
```cpp
error_message = "Failed to insert into tblPrimanota (rows " +
    std::to_string(batch_start) + "-" + std::to_string(batch_end - 1) +
    "): " + error_message;
```

This standardizes error messages to: `"Failed to insert into {tableName}: {mssql_error}"` or `"Failed to insert into {tableName} (rows N-M): {mssql_error}"`.
  </action>
  <verify>
Search the file for error message patterns:
1. `"Failed to insert into tblVorlauf:"` appears in InsertVorlauf
2. `"Failed to insert into tblPrimanota (rows"` appears in InsertPrimanota
3. No occurrences of the old patterns: `"Failed to insert Vorlauf:"` or `"Failed to insert tblPrimanota rows"`
  </verify>
  <done>
Error messages in InsertVorlauf and InsertPrimanota both follow the standardized format: `"Failed to insert into {tableName}: {error}"` with optional row range in parentheses.
  </done>
</task>

</tasks>

<verification>
After both tasks, verify:

1. **Transaction API usage:** `grep -n "BeginTransaction\|\.Commit\|\.Rollback\|HasActiveTransaction" src/into_wz_function.cpp` shows BeginTransaction, Commit, Rollback (guarded by HasActiveTransaction) in IntoWzExecute, plus the existing BeginTransaction/Commit pair in RegisterIntoWzFunction.

2. **No raw SQL transactions in IntoWzExecute:** The strings `"BEGIN TRANSACTION"`, `"COMMIT"`, `"ROLLBACK"` do NOT appear between the IntoWzExecute function start and end (they may still appear in comments or other functions).

3. **Error message format:** `grep -n "Failed to insert" src/into_wz_function.cpp` shows:
   - `"Failed to insert into tblVorlauf:"` in InsertVorlauf
   - `"Failed to insert into tblPrimanota (rows"` in InsertPrimanota

4. **try/catch structure:** The transaction block in IntoWzExecute is wrapped in try/catch with `bind_data.results.clear()` in the catch block.

5. **Build check (if possible):** Run build command to verify no compilation errors.
</verification>

<success_criteria>
- Steps 5-7 of IntoWzExecute use DuckDB C++ transaction API (BeginTransaction/Commit/Rollback)
- Rollback is guarded by HasActiveTransaction() -- "cannot rollback" error is impossible
- Error flow uses try/catch -- single catch block handles all failure modes
- Error messages use standardized format with table names tblVorlauf / tblPrimanota
- Catch block clears results before adding error -- no phantom success results after rollback
</success_criteria>

<output>
After completion, create `.planning/phases/02-transaction-fix/02-01-SUMMARY.md`
</output>
